#pragma kernel CSMain

#include "Assets/Shaders/Includes/Dissolver.cginc"

// inputs

StructuredBuffer<int> TrianglesBuffer;
StructuredBuffer<float3> VerticesBuffer;
StructuredBuffer<float2> UvBuffer;
Texture2D<float4> DissolveMap;
float DissolveRate;
float EdgeFadeIn;
float EdgeIn;
float EdgeOut;
float EdgeFadeOut;
float4x4 Transform;
uint TrianglesCount;
uint DissolveMapWidth;
uint DissolveMapHeight;
uint DestMapWidth;
uint DestMapHeight;
float DissolveThreshold;
float Time;

// outputs

RWTexture2D<float4> PositionMap;
RWTexture2D<float4> AlphaMap;

// ref:
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float random (float2 st) {
    return frac(sin(dot(st.xy,
                         float2(12.9898,78.233)))*
        43758.5453123);
}

// // ref: https://github.com/keijiro/Smrvfx/blob/d4d84cc60fe3f53055251510bf5cc47f87ad2333/Packages/jp.keijiro.smrvfx/Resources/SkinnedMeshBaker.compute
// // Hash function from H. Schechter & R. Bridson, goo.gl/RXiKaH
// uint Hash(uint s)
// {
//     s ^= 2747636419u;
//     s *= 2654435769u;
//     s ^= s >> 16;
//     s *= 2654435769u;
//     s ^= s >> 16;
//     s *= 2654435769u;
//     return s;
// }

[numthreads(1,1,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
    float idx = (float)id.x;
    float idy = (float)id.y;
    // float idx = (float)id.x + Time;
    // float idy = (float)id.y + Time;
    // float2 currentId = float2(idx, idy);

    // random sampling
    // uint targetIndex = Hash(id.x + id.y) % TrianglesCount;
    uint targetIndex = (uint)(random(float2(idx, idy)) * TrianglesCount);

    // for debug
    // targetIndex = id.y * DestMapWidth + id.x;

    int i1 = TrianglesBuffer[targetIndex * 3];
    int i2 = TrianglesBuffer[targetIndex * 3 + 1];
    int i3 = TrianglesBuffer[targetIndex * 3 + 2];

    float3 v1 = VerticesBuffer[i1];
    float3 v2 = VerticesBuffer[i2];
    float3 v3 = VerticesBuffer[i3];

    float2 uv1 = UvBuffer[i1];
    float2 uv2 = UvBuffer[i2];
    float2 uv3 = UvBuffer[i3];

    float weight1 = lerp(0, 1, random(float2(idx, idy)));
    float weight2 = lerp(0, 1 - weight1, random(float2(idy, idx)));
    float weight3 = 1 - (weight1 + weight2);

    // weight1 = frac(Time / 100);
    // weight2 = 1 - Time;
    // weight3 = 0;

float t = frac(Time) * 3;
if(t > 2) {
    weight1 = t - 2;
    weight3 = 1 - weight1;
    weight2 = 0;
} else if (t > 1) {
    weight3 = t - 1;
    weight2 = 1 - weight3;
    weight1 = 0;
} else {
    weight2 = t;
    weight1 = 1 - weight2;
    weight3 = 0;
}
    
    // // for debug
    // weight1 = 0.333;
    // weight2 = 0.333;
    // weight3 = 0.333;

    float2 uv =
        uv1 * weight1 +
        uv2 * weight2 +
        uv3 * weight3;

    float4 lp1 = float4(v1.x, v1.y, v1.z, 1);
    float4 lp2 = float4(v2.x, v2.y, v2.z, 1);
    float4 lp3 = float4(v3.x, v3.y, v3.z, 1);
    float4 wp1 = mul(Transform, lp1);
    float4 wp2 = mul(Transform, lp2);
    float4 wp3 = mul(Transform, lp3);

    float4 wp = 
        wp1 * weight1 +
        wp2 * weight2 +
        wp3 * weight3;

    float4 dissolveMapValue = DissolveMap[uint2(
        (uint)(uv.x * DissolveMapWidth),
        (uint)(uv.y * DissolveMapHeight)
    )];

    Dissolver o = dissolver(
        dissolveMapValue.x,
        DissolveRate,
        EdgeFadeIn,
        EdgeIn,
        EdgeOut,
        EdgeFadeOut
    );

    float alpha = clamp(sign(o.DissolveEdge - DissolveThreshold), 0, 1);

    PositionMap[id] = float4(wp.x, wp.y, wp.z, 1);
    // PositionMap[id] = float4(wp1.x, wp1.y, wp1.z, 1);
    // PositionMap[id] = float4(wp2.x, wp2.y, wp2.z, 1);
    // PositionMap[id] = float4(wp3.x, wp3.y, wp3.z, 1);
    // PositionMap[id] = float4(
    //     lerp(
    //         float3(0, 0, 0),
    //         float3(wp.x, wp.y, wp.z),
    //         alpha
    //     ), 1
    // );

    // for debug
    // PositionMap[id] = float4(uv.x, uv.y, 1, 1);
    // PositionMap[id] = float4(o.DissolveEdge, 0, 0, 1);
    // PositionMap[id] = float4(o.DissolveEdge, 0, 0, 1);

    AlphaMap[id] = float4(alpha, alpha, alpha, alpha);


    // // debug: position
    // DestTexture[id] = float4(
    //     wp.x, wp.y, wp.z, 1
    // );

    // uint index = id.y * DestTextureWidth + id.x;
    // float r = random(float2((float)id.x, (float)id.y)) * (float)(index < TrianglesCount ? 1 : 0);
    // // DestTexture[id] = float4(r, r, 1, 1);
    // DestTexture[id] = float4(o.DissolveEdge, 0, 0, 1);

    // DestTexture[id] = float4(t.x, 0, 0, 1);
    // DestTexture[id] = float4(dissolveMapValue.xyz, 1);
    // DestTexture[id] = float4((float)uv.x, (float)uv.y, 1, 1);
    // DestTexture[uv] = float4(
    //     id.x / DestTextureWidth,
    //     id.y / DestTextureHeight,
    //     0,
    //     1
    // );
    // DestTexture[uv] = float4(id.y * DestTextureWidth + id.x < TrianglesCount ? 1 : 0, 0, 0, 1);
    // DestTexture[uv] = float4(0, 0, 0, 1);
    // destTexture[id] = float4(1, 0, 0, 1);
}
