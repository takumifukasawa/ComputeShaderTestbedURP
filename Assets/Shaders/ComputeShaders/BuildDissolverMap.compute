#pragma kernel CSMain

#include "Assets/Shaders/Includes/Dissolver.cginc"

// inputs

StructuredBuffer<int> TrianglesBuffer;
StructuredBuffer<float3> VerticesBuffer;
StructuredBuffer<float2> UvBuffer;
Texture2D<float4> DissolveMap;
float DissolveRate;
float EdgeFadeIn;
float EdgeIn;
float EdgeOut;
float EdgeFadeOut;
float4x4 Transform;
uint SampleCount;
uint DissolveMapWidth;
uint DissolveMapHeight;
uint DestTextureWidth;
uint DestTextureHeight;
float DissolveThreshold;

// outputs

RWTexture2D<float4> PositionMap;
RWTexture2D<float4> AlphaMap;

// ref:
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float random (float2 st) {
    return frac(sin(dot(st.xy,
                         float2(12.9898,78.233)))*
        43758.5453123);
}

// // ref: https://github.com/keijiro/Smrvfx/blob/d4d84cc60fe3f53055251510bf5cc47f87ad2333/Packages/jp.keijiro.smrvfx/Resources/SkinnedMeshBaker.compute
// // Hash function from H. Schechter & R. Bridson, goo.gl/RXiKaH
uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

[numthreads(1,1,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
    // random sampling
    uint targetIndex = Hash(id.x + id.y) % SampleCount;
    // uint targetIndex = (uint)(random(float2((float)id.x, (float)id.y)) * SampleCount);

    int ti1 = TrianglesBuffer[targetIndex * 3];
    int ti2 = TrianglesBuffer[targetIndex * 3 + 1];
    int ti3 = TrianglesBuffer[targetIndex * 3 + 2];

    float3 v1 = VerticesBuffer[ti1];
    float3 v2 = VerticesBuffer[ti2];
    float3 v3 = VerticesBuffer[ti3];

    float2 uv1 = UvBuffer[ti1];
    float2 uv2 = UvBuffer[ti2];
    float2 uv3 = UvBuffer[ti3];

    float weight1 = lerp(0, 1, random(float2((float)id.x, (float)id.y)));
    float weight2 = lerp(0, 1 - weight1, random(float2((float)id.y, (float)id.x)));
    float weight3 = 1 - (weight1 + weight2);

    float2 uv =
        uv1 * weight1 +
        uv2 * weight2 +
        uv3 * weight3;
    
    float4 lp1 = float4(v1.x, v1.y, v1.z, 1);
    float4 lp2 = float4(v2.x, v2.y, v2.z, 1);
    float4 lp3 = float4(v3.x, v3.y, v3.z, 1);
    float4 wp1 = mul(Transform, lp1);
    float4 wp2 = mul(Transform, lp2);
    float4 wp3 = mul(Transform, lp3);

    float4 wp = 
        wp1 * weight1 +
        wp2 * weight2 +
        wp3 * weight3;

    float4 dissolveMapValue = DissolveMap[uint2(
        (uint)(uv.x * DissolveMapWidth),
        (uint)(uv.y * DissolveMapHeight)
    )];

    Dissolver o = dissolver(
        dissolveMapValue.x,
        DissolveRate,
        EdgeFadeIn,
        EdgeIn,
        EdgeOut,
        EdgeFadeOut
    );

    float alpha = clamp(sign(o.DissolveEdge - DissolveThreshold), 0, 1);

    PositionMap[id] = float4(wp.x, wp.y, wp.z, 1);
    // PositionMap[id] = float4(
    //     lerp(
    //         float3(0, 0, 0),
    //         float3(wp.x, wp.y, wp.z),
    //         alpha
    //     ), 1
    // );

    AlphaMap[id] = float4(alpha, alpha, alpha, alpha);

    // // debug: position
    // DestTexture[id] = float4(
    //     wp.x, wp.y, wp.z, 1
    // );

    // uint index = id.y * DestTextureWidth + id.x;
    // float r = random(float2((float)id.x, (float)id.y)) * (float)(index < SampleCount ? 1 : 0);
    // // DestTexture[id] = float4(r, r, 1, 1);
    // DestTexture[id] = float4(o.DissolveEdge, 0, 0, 1);

    // DestTexture[id] = float4(t.x, 0, 0, 1);
    // DestTexture[id] = float4(dissolveMapValue.xyz, 1);
    // DestTexture[id] = float4((float)uv.x, (float)uv.y, 1, 1);
    // DestTexture[uv] = float4(
    //     id.x / DestTextureWidth,
    //     id.y / DestTextureHeight,
    //     0,
    //     1
    // );
    // DestTexture[uv] = float4(id.y * DestTextureWidth + id.x < SampleCount ? 1 : 0, 0, 0, 1);
    // DestTexture[uv] = float4(0, 0, 0, 1);
    // destTexture[id] = float4(1, 0, 0, 1);
}
